[
{
  "model": "currency_exchange.provider",
  "pk": 1,
  "fields": {
    "creation_datetime": "2024-01-22T10:24:46.586Z",
    "modification_datetime": "2024-01-24T10:22:31.243Z",
    "name": "Fixer",
    "priority": 2,
    "adapter_code": "from datetime import datetime\r\nfrom decimal import Decimal\r\nfrom typing import List, Dict\r\n\r\nimport requests\r\nfrom currency_exchange.adapters.base import CurrencyRateAdapter\r\n\r\nBASE_URL = \"http://data.fixer.io/api/\"\r\nACCESS_KEY = \"\"  # Replace with your Fixer.io access key\r\n\r\n\r\nclass FixerAdapter(CurrencyRateAdapter):\r\n    def __init__(self, access_key: str = ACCESS_KEY, base_url: str = BASE_URL):\r\n        self.base_url = base_url\r\n        self.access_key = access_key\r\n\r\n    def get_exchange_rates(self, source_currency_code: str, exchange_currency_codes: List[str], valuation_date: str) -> Dict[str, Decimal]:\r\n        \"\"\"\r\n        Get exchange rate from Fixer.io and return as Decimal.\r\n\r\n        :param source_currency_code: The base currency code.\r\n        :param exchange_currency_codes: The target currency codes.\r\n        :param valuation_date: The date for which to get the exchange rate.\r\n        :return: Exchange rate as Decimal.\r\n        \"\"\"\r\n       # Validate input\r\n        if not (source_currency_code and exchange_currency_codes):\r\n            raise ValueError(\"Currency codes cannot be empty.\")\r\n\r\n        try:\r\n            datetime.strptime(valuation_date, '%Y-%m-%d')\r\n        except ValueError:\r\n            raise ValueError(\"'valuation_date' must be in YYYY-MM-DD format.\")\r\n\r\n        exchange_currency_codes = ','.join(exchange_currency_codes)\r\n        url = f\"{self.base_url}{valuation_date}?access_key={self.access_key}&base={source_currency_code}&symbols={exchange_currency_codes}\"\r\n\r\n        try:\r\n            response = requests.get(url)\r\n            response.raise_for_status()  # Raise an HTTPError for bad responses\r\n            data = response.json()\r\n\r\n            # Error handling for response data\r\n            if 'rates' not in data:\r\n                raise ValueError(f\"Invalid data received from currency rate service. Info: {data!r}.\")\r\n\r\n            return data['rates']\r\n\r\n        except requests.RequestException as e:\r\n            # Handle any requests-related issues\r\n            raise ConnectionError(\"Error connecting to Fixer.io service.\") from e\r\n        except Exception as e:\r\n            # Handle other exceptions\r\n            raise e\r\n\r\nadapter = FixerAdapter()\r\nreturn_value = adapter.get_exchange_rates(source_currency, exchange_currencies, valuation_date)"
  }
},
{
  "model": "currency_exchange.provider",
  "pk": 3,
  "fields": {
    "creation_datetime": "2024-01-24T10:20:22.622Z",
    "modification_datetime": "2024-01-24T10:20:22.622Z",
    "name": "Mock",
    "priority": 1,
    "adapter_code": "import random\r\nfrom datetime import datetime\r\nfrom decimal import Decimal\r\nfrom typing import List, Dict\r\n\r\nfrom currency_exchange.adapters.base import CurrencyRateAdapter\r\nfrom currency_exchange.models.currency import AVAILABLE_CURRENCIES\r\n\r\n\r\nclass MockAdapter(CurrencyRateAdapter):\r\n    def __init__(self):\r\n        self.available_currencies = AVAILABLE_CURRENCIES\r\n\r\n    def _generate_mock_rates(self, source_currency: str):\r\n        \"\"\"\r\n        Generate mock exchange rates for a given currency.\r\n        \"\"\"\r\n        rates = {}\r\n        for currency in self.available_currencies:\r\n            if currency != source_currency:\r\n                rates[currency] = Decimal(random.uniform(0.5, 1.5)).quantize(Decimal('.0001'))\r\n        return rates\r\n\r\n    def get_exchange_rates(self, source_currency_code: str, exchange_currency_codes: List[str], valuation_date: str) -> Dict[str, Decimal]:\r\n        \"\"\"\r\n        Simulate getting exchange rates for a given date and return as Decimal.\r\n\r\n        :param source_currency_code: The base currency code.\r\n        :param exchange_currency_codes: The target currency codes.\r\n        :param valuation_date: The date for which to get the exchange rate.\r\n        :return: Exchange rates as Decimal.\r\n        \"\"\"\r\n        if not (source_currency_code and exchange_currency_codes):\r\n            raise ValueError(\"Currency codes cannot be empty.\")\r\n\r\n        try:\r\n            datetime.strptime(valuation_date, '%Y-%m-%d')\r\n        except ValueError:\r\n            raise ValueError(\"'valuation_date' must be in YYYY-MM-DD format.\")\r\n\r\n        if source_currency_code not in self.available_currencies:\r\n            raise ValueError(f\"Invalid source currency: {source_currency_code}\")\r\n\r\n        mock_rates = self._generate_mock_rates(source_currency_code)\r\n\r\n        filtered_rates = {code: mock_rates.get(code, Decimal('0.0')) for code in exchange_currency_codes}\r\n\r\n        return filtered_rates\r\n\r\nadapter = MockAdapter()\r\nreturn_value = adapter.get_exchange_rates(source_currency, exchange_currencies, valuation_date)"
  }
}
]
